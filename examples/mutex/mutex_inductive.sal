mutex: CONTEXT =
	BEGIN
  	P1: TYPE = PROCESS_TYPE;
  	%P1: TYPE = [1..3];

		mutex: MODULE =
			BEGIN
				OUTPUT
					want: ARRAY P1 OF BOOLEAN,
					crit: ARRAY P1 OF BOOLEAN,
					turn: P1,
					i: P1

				INITIALIZATION
				    % want = [[P1] False]
					% crit = [False]
					want IN { a: ARRAY P1 OF BOOLEAN | FORALL(i:P1): NOT a[i] };
					crit IN { a: ARRAY P1 OF BOOLEAN | FORALL(i:P1): NOT a[i] };

				TRANSITION
				[
				  NOT want[i] -->
				  		% want' = want WITH [i] = True
						want' IN { a: ARRAY P1 OF BOOLEAN |
							FORALL(j: P1):
								(a[j] AND (i = j OR want[j])) OR 
								((NOT a[j]) AND (NOT(i = j OR want[j])))
						};
						i IN { i:P1| TRUE };
				[]
					want[i] AND NOT crit[i] AND turn = i -->
  					% crit' = crit WITH [i] = True
						crit' IN { a: ARRAY P1 OF BOOLEAN |
							FORALL(j: P1):
								(a[j] AND (i = j OR crit[j])) OR
								(NOT a[j] AND (NOT (i = j OR crit[j])))
						};
						i IN { i:P1| TRUE };
				[]
					crit[i] -->
   					% want = with WITH [i] = False
	  				% crit' = crit WITH [i] = False
						turn' IN { a : P1 | TRUE };
						crit' IN { a: ARRAY P1 OF BOOLEAN |
							FORALL(j: P1):
								(a[j] AND (i /= j AND crit[j])) OR
								(NOT a[j] AND NOT (i /= j AND crit[j]))
						};
						want' IN { a: ARRAY P1 OF BOOLEAN |
							FORALL(j: P1):
								(a[j] AND (i /= j AND want[j])) OR
								(NOT a[j] AND NOT (i /= j AND want[j]))
						};
						i IN { i:P1| TRUE };
				]
			END;

		safe: LEMMA
			mutex |- G(FORALL (j: P1): (crit[i] AND crit[j] => i = j) AND (crit[j] => turn = j));

	END
