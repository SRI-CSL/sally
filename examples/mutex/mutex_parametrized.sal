mutex: CONTEXT =
BEGIN
  P1: TYPE = PROCESS_TYPE;
  
  mutex: MODULE =
  BEGIN
    OUTPUT
      want: ARRAY P1 OF BOOLEAN,
      crit: ARRAY P1 OF BOOLEAN,
      turn: P1,
      i: P1
      
    INITIALIZATION
      % want = [[P1] False]
      % crit = [False]
      want IN { a: ARRAY P1 OF BOOLEAN | FORALL(i:P1): NOT a[i] };
      crit IN { a: ARRAY P1 OF BOOLEAN | FORALL(i:P1): NOT a[i] };
      
    TRANSITION
    [
      NOT want[i] -->
        % want' = want WITH [i] = True
        want' IN { a: ARRAY P1 OF BOOLEAN |
          FORALL(j: P1):
            (a[j] AND (i = j OR want[j])) OR 
            ((NOT a[j]) AND (NOT(i = j OR want[j])))
        };
        i IN { i:P1| TRUE };
    []
      want[i] AND NOT crit[i] AND turn = i -->
  	% crit' = crit WITH [i] = True
	crit' IN { a: ARRAY P1 OF BOOLEAN |
	  FORALL(j: P1):
	    (a[j] AND (i = j OR crit[j])) OR
	    (NOT a[j] AND (NOT (i = j OR crit[j])))
	};
        i IN { i:P1| TRUE };
    []
      crit[i] -->
   	% want = with WITH [i] = False
	% crit' = crit WITH [i] = False
        turn' IN { a : P1 | TRUE };
        crit' IN { a: ARRAY P1 OF BOOLEAN |
          FORALL(j: P1):
            (a[j] AND (i /= j AND crit[j])) OR
            (NOT a[j] AND NOT (i /= j AND crit[j]))
        };
        want' IN { a: ARRAY P1 OF BOOLEAN |
          FORALL(j: P1):
            (a[j] AND (i /= j AND want[j])) OR
            (NOT a[j] AND NOT (i /= j AND want[j]))
        };
        i IN { i:P1| TRUE };
    ]
  END;
        
  safe: LEMMA
    mutex |- G(FORALL (j: P1): (crit[i] AND crit[j] => i = j) AND (crit[j] => turn = j));
    
END
