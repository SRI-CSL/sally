%
% Byzantine fault tolerant OM protocol without relays
%

om_parametric: CONTEXT =
BEGIN

  N: NATURAL;  % number of processes

  PID: TYPE = [1 .. N];

  DATA: TYPE = BOOL;
  val: BOOL;

  % Data from the source
  source: PID;

  %
  % Fault assumptions
  %
  faults(a: ARRAY PID OF BOOLEAN): N - #{x:PID | a[x]}
  all_good(a: ARRAY PID OF BOOLEAN): faults(a) = 0


  %
  % OM protocol: flat representation
  %  cx[i][j] = channel from process i to process j
  %  good_p[i] = true if process i is non-faulty
  %  v[i] = value chosen by process i
  %  round = round counter
  % Process 1 is the Byzantine general
  %
  % Fault model: a faulty process is Byzantine
  %
  OM: MODULE =
  BEGIN
    OUTPUT
      cx: ARRAY PID OF ARRAY PID OF DATA,
      good_p: ARRAY PID OF BOOLEAN,
      v:  ARRAY PID OF DATA,
      round: NATURAL
    INITIALIZATION
      round = 0;
      cx[source][source] = val;
      good_p IN { a: ARRAY PID OF BOOLEAN | 3*faults(a) < N  };

    TRANSITION
     [ round < 2 -->
         cx' = [[i:PID] [j: PID] 
		 			c IN { v | good_p[i] => (v = cx[source][i]) }
				]
         round' = round + 1;
    []
       round = 2 -->
         v' = [[i:PID] v[i] = majority(cx[i])]
         round' = 3;
    []
       round = 3 --> %% done
     ]
  END;

  agreement: LEMMA
    OM |- G(round >= 3 /\ good_p(source) => #{i: PID | good_p(i) => v[i] = val} = N)

  agreement_traitor_general: LEMMA
    OM |- G(round >= 3 #{i: PID | good_p(i) AND (NOT good_p(source)) => v[i] = majority(v)} = N)

END
